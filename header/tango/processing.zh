// tango.zh alpha 3
// Constants and functions related to processing strings.

// String states
const int __TANGO_STATE_INACTIVE  = 0;
const int __TANGO_STATE_ACTIVE    = 1;
const int __TANGO_STATE_FINISHED  = 2;
const int __TANGO_STATE_ADVANCING = 3;
const int __TANGO_STATE_RESERVED  = 4;
const int __TANGO_STATE_MENU_WAIT = 5;
const int __TANGO_STATE_SYNC_WAIT = 6;
const int __TANGO_STATE_PRESS_A   = 7;

// Update speeds
const int __TANGO_SPEED_NORMAL  = 0;
const int __TANGO_SPEED_FAST    = 1;
const int __TANGO_SPEED_INSTANT = 2;



void __Tango_CheckScreenChange()
{
    int screen=(Game->GetCurDMap()<<8)+Game->GetCurDMapScreen();
    
    if(__Tango_Data[__TDIDX_PREV_SCREEN]!=screen)
    {
        __Tango_Data[__TDIDX_PREV_SCREEN]=screen;
        
        // Clear every string that doesn't carry over.
        
        int state;
        int flags;
        for(int i=0; i<__TANGO_NUM_STRINGS; i++)
        {
            state=__Tango_GetStringState(i);
            flags=__Tango_GetStringFlags(i);
            
            // Reserved state is cleared even if the carry over flag is set.
            if((flags&TANGO_FLAG_CARRY_OVER)==0 ||
               state==__TANGO_STATE_RESERVED)
                Tango_ClearString(i);
        }
    }
}

// Updates each string and the menu.
void Tango_Update1()
{
    bool blockAll=false;
    Screen->SetRenderTarget(__TANGO_BITMAP);    
    __Tango_CheckScreenChange();
    
    // Update the menu first
    if(Tango_MenuIsActive())
    {
        __Tango_UpdateMenu();
        blockAll=true; // Menus always block all input
    }
    
    // Menu keys are cleared before other updates so that holding the button
    // after making a selection doesn't speed through the following text.
    if((__Tango_Data[__TDIDX_GLOBAL_FLAGS]&__TANGO_GFLAG_UNPRESS_MENU)!=0)
    {
        if(__Tango_InputMenu())
            __Tango_UnpressMenu();
        else
            __Tango_Data[__TDIDX_GLOBAL_FLAGS]&=~__TANGO_GFLAG_UNPRESS_MENU;
    }
    
    // Now each string is updated.
    for(int i=0; i<__TANGO_NUM_STRINGS; i++)
    {
        __Tango_SetCurrentString(i);
        __Tango_UpdateCurrentString();
    }
    
    // And then any remaining input blocking is handled.
    int flags=__Tango_Data[__TDIDX_GLOBAL_FLAGS];
    
    // Flags that unset specific buttons stay set for as long as their
    // buttons are held.
    if((flags&__TANGO_GFLAG_UNPRESS_SPEEDUP)!=0)
    {
        if(__Tango_InputSpeedup())
            __Tango_UnpressSpeedup();
        else
            flags&=~__TANGO_GFLAG_UNPRESS_SPEEDUP;
    }
    
    if((flags&__TANGO_GFLAG_UNPRESS_SUPER_SPEED)!=0)
    {
        if(__Tango_InputSuperSpeed())
            __Tango_UnpressSuperSpeed();
        else
            flags&=~__TANGO_GFLAG_UNPRESS_SUPER_SPEED;
    }
    
    if((flags&__TANGO_GFLAG_UNPRESS_ADVANCE)!=0)
    {
        if(__Tango_InputAdvance())
            __Tango_UnpressAdvance();
        else
            flags&=~__TANGO_GFLAG_UNPRESS_ADVANCE;
    }
    
    // The "unpress all" flag isn't persistent.
    if((flags&__TANGO_GFLAG_UNPRESS_ALL)!=0 || blockAll)
    {
        __Tango_UnpressAll();
        flags&=~__TANGO_GFLAG_UNPRESS_ALL;
    }
    
    __Tango_Data[__TDIDX_GLOBAL_FLAGS]=flags;
    
    Screen->SetRenderTarget(RT_SCREEN);
}

// Draws each active string to the screen.
void Tango_Update2()
{
    Screen->SetRenderTarget(RT_SCREEN);
    
    int state;
    int dataStart;
    
    for(int i=0; i<__TANGO_NUM_STRINGS; i++)
    {
        __Tango_SetCurrentString(i);
        state=__Tango_GetCurrStrData(__TSDIDX_STATE);
        
        if(state!=__TANGO_STATE_INACTIVE &&
           state!=__TANGO_STATE_RESERVED)
            __Tango_DrawToScreen();
    }
    
    if(Tango_MenuIsActive())
        __Tango_DrawMenuCursor();
}

void __Tango_UpdateCurrentString()
{
    int dataStart=__Tango_Data[__TCS_DATA_START];
    int state=__Tango_StringData[dataStart+__TSDIDX_STATE];
    
    if(state==__TANGO_STATE_INACTIVE || state==__TANGO_STATE_RESERVED)
        return;
    
    // Check speed and input blocking flags
    
    int styleStart=__Tango_Data[__TCS_STYLE_START];
    int defStart=__Tango_Data[__TCS_DEF_START];
    int flags=__Tango_Styles[styleStart+TANGO_STYLE_FLAGS];
    int speed=__TANGO_SPEED_NORMAL;
    
    if((flags&TANGO_FLAG_ENABLE_SPEEDUP)!=0)
    {
        __Tango_Data[__TDIDX_GLOBAL_FLAGS]|=__TANGO_GFLAG_UNPRESS_SPEEDUP;
        if(__Tango_InputSpeedup())
            speed=__TANGO_SPEED_FAST;
    }
    
    if((flags&TANGO_FLAG_ENABLE_SUPER_SPEED)!=0)
    {
        __Tango_Data[__TDIDX_GLOBAL_FLAGS]|=__TANGO_GFLAG_UNPRESS_SUPER_SPEED;
        if(__Tango_InputSuperSpeed())
            speed=__TANGO_SPEED_INSTANT;
    }
    
    if((flags&TANGO_FLAG_BLOCK_INPUT)!=0)
        __Tango_Data[__TDIDX_GLOBAL_FLAGS]|=__TANGO_GFLAG_UNPRESS_ALL;
    
    // Now to actually update the string...
    
    if(state==__TANGO_STATE_PRESS_A)
    {
        if(__Tango_PressAdvance())
        {
            state=__TANGO_STATE_ACTIVE;
            __Tango_SetCurrStrData(__TSDIDX_STATE, __TANGO_STATE_ACTIVE);
        }
    }
    
    if(state==__TANGO_STATE_ACTIVE)
    {
        // Scroll and count down the delay if needed.
        // Both are done at once.
        if(__Tango_StringData[dataStart+__TSDIDX_COUNTER]>0)
            __Tango_CountDown(speed);
        if(__Tango_StringData[dataStart+__TSDIDX_SCROLLING]>0)
            __Tango_Scroll(speed);
        if(__Tango_StringData[dataStart+__TSDIDX_COUNTER]==0 &&
           __Tango_StringData[dataStart+__TSDIDX_SCROLLING]==0)
            __Tango_Process(speed);
    } // End active
    
    else if(state==__TANGO_STATE_FINISHED)
    {
        bool done=false;
        
        if((flags&TANGO_FLAG_AUTO_ADVANCE)!=0)
        {
            if(__Tango_StringData[dataStart+__TSDIDX_COUNTER]>0)
                __Tango_CountDown(speed);
            else
                done=true;
        }
        else if(__Tango_PressAdvance())
        {
            done=true;
            __Tango_Data[__TDIDX_GLOBAL_FLAGS]|=__TANGO_GFLAG_UNPRESS_ADVANCE;
        }
        
        // The string is finished; either clear it out or get ready for
        // the next one
        if(done)
        {
            if(__Tango_StringData[dataStart+__TSDIDX_NEXT_STRING]==0)
            {
                // No next string; clear it, unless the persistent flag is set.
                if((flags&TANGO_FLAG_PERSISTENT)==0)
                    Tango_ClearString(__Tango_Data[__TCS_ID]);
            }
            else
                __Tango_BeginAdvancing();
        }
    } // End finished
    
    else if(state==__TANGO_STATE_ADVANCING)
    {
        bool done=false;
        
        if(__TANGO_SCROLL_TO_NEXT!=0)
            done=__Tango_Scroll(speed);
        else
            done=true;
        
        if(done)
        {
            // Load the next message, reset the text position and string state,
            // and clear the bitmap.
            Tango_SetMessage(__Tango_Data[__TCS_ID],
                __Tango_StringData[dataStart+__TSDIDX_NEXT_STRING]);
            __Tango_StringData[dataStart+__TSDIDX_NEXT_STRING]=0;
            __Tango_StringData[dataStart+__TSDIDX_POSITION]=
                __Tango_GetCurrStrDefData(__TANGO_STRDEF_START);
            __Tango_StringData[dataStart+__TSDIDX_CHAR_X]=
                __TANGO_STRING_DEFS[defStart+__TANGO_STRDEF_X];
            __Tango_StringData[dataStart+__TSDIDX_CHAR_Y]=
                __TANGO_STRING_DEFS[defStart+__TANGO_STRDEF_Y];
            __Tango_StringData[dataStart+__TSDIDX_OFFSET]=0;
            __Tango_StringData[dataStart+__TSDIDX_SCROLLING]=0;
            __Tango_ClearStringBitmap(__Tango_Data[__TCS_ID]);
            
            __Tango_StringData[dataStart+__TSDIDX_STATE]=
                __TANGO_STATE_ACTIVE;
        }
    } // End advancing
}

// Processes characters in the string until it encounters a delay.
void __Tango_Process(int speed)
{
    int stringID=__Tango_Data[__TCS_ID];
    int dataStart=__Tango_Data[__TCS_DATA_START];
    int styleStart=__Tango_Data[__TCS_STYLE_START];
    
    bool done=false;
    int position=Tango_GetStringData(stringID, __TSDIDX_POSITION);
    int character=__Tango_StringBuffer[position];
    int defStart=stringID*__TANGO_SIZEOF_STRDEF;
    int font=__Tango_Styles[styleStart+TANGO_STYLE_TEXT_FONT];
    int left;
    int right;
    bool newLine;
    bool setDelay;
    bool isMenu=false;
    int choiceCounter=0;
    int scrolling;
    bool lineByLine=
      (__Tango_Styles[styleStart+TANGO_STYLE_FLAGS]&TANGO_FLAG_LINE_BY_LINE)!=0;
    
    __Tango_Data[__TDIDX_REFRESH_STYLE]=0;
    
    while(!done)
    {
        newLine=false;
        setDelay=false;
        
        // Space or printable character
        if(character>=TANGO_CHAR_SPACE)
        {
            __Tango_StringData[dataStart+__TSDIDX_CHAR_X]+=
              __Tango_PutChar(character, font,
                              __Tango_GetCurrentCSet(),
                              __Tango_GetCurrentColor(),
                              __Tango_StringData[dataStart+__TSDIDX_CHAR_X],
                              __Tango_StringData[dataStart+__TSDIDX_CHAR_Y],
                              0);
            if((character>TANGO_CHAR_SPACE || __TANGO_SFX_ON_SPACE!=0) &&
               !isMenu && speed!=__TANGO_SPEED_INSTANT && !lineByLine)
                Game->PlaySound(__Tango_GetCurrentSFX());
            position++;
        }
        
        else if(character==__TANGO_SETTER_MARKER)
        {
            __Tango_RunSetter(position, true);
            position+=6; // It must be at least six characters long;
                         // might as well skip ahead a bit
            
            // If @style was set, all the style data needs reloaded
            if(__Tango_Data[__TDIDX_REFRESH_STYLE]!=0)
            {
                styleStart=__Tango_Data[__TCS_STYLE_START];
                font=__Tango_Styles[styleStart+TANGO_STYLE_TEXT_FONT];
                lineByLine=
                  (__Tango_Styles[styleStart+TANGO_STYLE_FLAGS]&TANGO_FLAG_LINE_BY_LINE)!=0;
                
                __Tango_Data[__TDIDX_REFRESH_STYLE]=0;
            }
        }
        
        else if(character==__TANGO_FUNC_MARKER)
        {
            int ret=__Tango_RunFunction(position, true);
            if(ret>0 && !isMenu)
                done=true;
            // No position increment - may have put text
        }
        
        else if(character==__TANGO_FLOW_MARKER)
        {
            int ret=__Tango_RunFlowControl(position);
            if(ret>0 && !isMenu)
                done=true;
            // No position increment - may need repeated
        }
        
        else if(character==TANGO_CHAR_NEWLINE)
        {
            newLine=true;
            position++;
        }
        
        else if(character==__TANGO_CHAR_CHOICE)
        {
            if(!isMenu)
            {
                __Tango_InitializeMenu(styleStart);
                isMenu=true;
            }
            
            __Tango_ReadChoice(position, dataStart, styleStart);
            __Tango_StringData[dataStart+__TSDIDX_CHAR_X]+=
                __Tango_Styles[styleStart+TANGO_STYLE_MENU_CURSOR_WIDTH];
            
            choiceCounter++;
            position+=2;
        }
        
        else if(character==__TANGO_CHAR_MENU_END)
        {
            position++;
            break; // Don't check the next character
        }
        
        else if(character==NULL)
        {
            __Tango_StringData[dataStart+__TSDIDX_STATE]=__TANGO_STATE_FINISHED;
            Game->PlaySound(__Tango_Styles[styleStart+TANGO_STYLE_TEXT_END_SFX]);
            if((__Tango_Styles[styleStart+TANGO_STYLE_FLAGS]&TANGO_FLAG_AUTO_ADVANCE)!=0 &&
               speed!=__TANGO_SPEED_INSTANT)
                __Tango_StringData[dataStart+__TSDIDX_COUNTER]=__TANGO_AUTO_ADVANCE_TIME;
            break; // Don't check the next character
        }
        
        else
        {
            // Either filler or something that isn't valid here.
            if(character!=__TANGO_CHAR_FILLER)
                __Tango_LogError(__TANGO_ERROR_BAD_CHARACTER, character);
            position++;
        }
        
        // Load up the next character. If it's a text character,
        // there should normally be a delay before processing it.
        // It might also need to go on a new line.
        
        character=__Tango_StringBuffer[position];
        
        if(character>=TANGO_CHAR_SPACE)
        {
            // TODO check for space delay setting
            if(speed!=__TANGO_SPEED_INSTANT && !isMenu && !lineByLine)
                setDelay=true;
        } // End next character check
        
        // See if the next character or word is too big to fit
        // on the current line.
        if(!newLine)
            newLine=__Tango_NeedsNewLine(stringID, position);
        
        if(newLine)
        {
            scrolling=__Tango_StartNewLine();
            if(scrolling>0)
            {
                if(isMenu || speed==__TANGO_SPEED_INSTANT)
                {
                    __Tango_StringData[dataStart+__TSDIDX_OFFSET]+=scrolling;
                    if(isMenu)
                        __Tango_ShiftMenu(scrolling);
                }
                else
                {
                    __Tango_StringData[dataStart+__TSDIDX_SCROLLING]=scrolling;
                    done=true;
                }
            }
            
            if(lineByLine)
                setDelay=true;
        }
        
        if(setDelay)
        {
            // Add to the delay instead of setting it so this doesn't
            // interfere with @delay
            __Tango_StringData[dataStart+__TSDIDX_COUNTER]+=
                __Tango_GetCurrentSpeed();
            done=true;
        }
    }
    
    // Only play the sound once per line.
    if(lineByLine)
        Game->PlaySound(__Tango_GetCurrentSFX());
    
    __Tango_StringData[dataStart+__TSDIDX_POSITION]=position;
}

// Determines whether the next character or word will fit on the
// current line. Newline characters are not handled here.
bool __Tango_NeedsNewLine(int stringID, int pos)
{
    int character=__Tango_StringBuffer[pos];
    
    int dataStart=__Tango_Data[__TCS_DATA_START];
    int defStart=__Tango_Data[__TCS_DEF_START];
    int styleStart=__Tango_Data[__TCS_STYLE_START];
    int font=__Tango_Data[__TCS_FONT];
    
    int left=__Tango_StringData[dataStart+__TSDIDX_CHAR_X];
    int right=__TANGO_STRING_DEFS[defStart+__TANGO_STRDEF_X]+
      __Tango_Styles[styleStart+TANGO_STYLE_TEXT_WIDTH];
    
    // Choices fit on the current line if the following word fits.
    if(character==__TANGO_CHAR_CHOICE)
    {
        character=__Tango_StringBuffer[pos+1];
        left+=__Tango_Styles[styleStart+TANGO_STYLE_MENU_CURSOR_WIDTH];
        
        // If this is a function, it may print text, so evaluate it
        // and reread the character.
        if(character==__TANGO_FUNC_MARKER)
        {
            __Tango_RunFunction(pos, true);
            character=__Tango_StringBuffer[pos];
        }
        
        // If the next character is the start of a word, see if it fits.
        // Anything else, just assume it does.
        if(character<=__TANGO_PRINTABLE_CHAR)
            return !__Tango_WordWillFit(pos+2, font, left, right);
        else
            return true;
    }
    
    // Unprintable characters, including spaces, are always considered
    // to fit on the current line.
    else if(character<=TANGO_CHAR_SPACE)
        return false;
    
    // Must be a printable character. Does the character itself fit?
    if(!__Tango_CharacterWillFit(character, font, left, right))
        return true;
    
    // If so, see if it's the start of a word.
    // Look for the previous text character or menu item marker.
    bool wordStart=false;
    int stringStart=__Tango_Data[__TCS_START];
    for(int i=pos-1; i>stringStart; i--)
    {
        character=__Tango_StringBuffer[i];
        
        if(character==TANGO_CHAR_SPACE || character==__TANGO_CHAR_CHOICE)
        {
            wordStart=true;
            break;
        }
        else if(character>=__TANGO_PRINTABLE_CHAR)
        {
            wordStart=false;
            break;
        }
    }
    
    // if this is the start of a word, see if the word fits.
    if(wordStart)
        return !__Tango_WordWillFit(pos, font, left, right);
    
    // Otherwise, it must fit.
    return false;
}

// Starts a new line. Returns the amount the text needs to scroll.
int __Tango_StartNewLine()
{
    int dataStart=__Tango_Data[__TCS_DATA_START];
    
    __Tango_StringData[dataStart+__TSDIDX_CHAR_X]=__Tango_GetBitmapX();
    __Tango_StringData[dataStart+__TSDIDX_CHAR_Y]+=__Tango_GetLineHeight();
    
    return __Tango_GetTargetOffset()-
             __Tango_StringData[dataStart+__TSDIDX_OFFSET];
}

// Count down the state counter.
void __Tango_CountDown(int speed)
{
    int dataStart=__Tango_Data[__TCS_DATA_START];
    
    int amount=1;
    if(speed==__TANGO_SPEED_FAST)
        amount*=__TANGO_SPEEDUP_FACTOR;
    
    __Tango_StringData[dataStart+__TSDIDX_COUNTER]=Max(0, 
        __Tango_StringData[dataStart+__TSDIDX_COUNTER]-amount);
}

// Scroll down to display the next line or the next string.
bool __Tango_Scroll(int speed)
{
    int dataStart=__Tango_Data[__TCS_DATA_START];
    
    if(speed==__TANGO_SPEED_INSTANT)
    {
        __Tango_StringData[dataStart+__TSDIDX_OFFSET]+=
            __Tango_StringData[dataStart+__TSDIDX_SCROLLING];
        __Tango_StringData[dataStart+__TSDIDX_SCROLLING]=0;
        return true;
    }
    else
    {
        int amount=__TANGO_SCROLL_SPEED;
        if(speed==__TANGO_SPEED_FAST)
            amount*=__TANGO_SPEEDUP_FACTOR;
        
        if(__Tango_StringData[dataStart+__TSDIDX_SCROLLING]<=amount)
        {
            // Won't scroll all the way down this time.
            __Tango_StringData[dataStart+__TSDIDX_OFFSET]+=
                __Tango_StringData[dataStart+__TSDIDX_SCROLLING];
            __Tango_StringData[dataStart+__TSDIDX_SCROLLING]=0;
            return true;
        }

        else
        {
            // Scroll all the way.
            __Tango_StringData[dataStart+__TSDIDX_OFFSET]+=amount;
            __Tango_StringData[dataStart+__TSDIDX_SCROLLING]-=amount;
            
            // If scrolling to the next string, use the state counter
            // to track the reduction in drawing size.
            if(__Tango_StringData[dataStart+__TSDIDX_STATE]==__TANGO_STATE_ADVANCING)
                __Tango_StringData[dataStart+__TSDIDX_COUNTER]+=amount;
            return false;
        }
    }
}

// Set the string up to advance to the next.
void __Tango_BeginAdvancing()
{
    __Tango_SetCurrStrData(__TSDIDX_STATE, __TANGO_STATE_ADVANCING);
    __Tango_SetCurrStrData(__TSDIDX_SCROLLING,
                           __Tango_GetCurrStyleData(TANGO_STYLE_TEXT_HEIGHT));
    __Tango_SetCurrStrData(__TSDIDX_COUNTER, 0);
}

void __Tango_UnpressAll()
{
    Link->InputUp = false;
    Link->PressUp = false;
    Link->InputDown = false;
    Link->PressDown = false;
    Link->InputLeft = false;
    Link->PressLeft = false;
    Link->InputRight = false;
    Link->PressRight = false;
    
    Link->InputA = false;
    Link->PressA = false;
    Link->InputB = false;
    Link->PressB = false;
    Link->InputL = false;
    Link->PressL = false;
    Link->InputR = false;
    Link->PressR = false;
    
    Link->InputEx1 = false;
    Link->PressEx1 = false;
    Link->InputEx2 = false;
    Link->PressEx2 = false;
    Link->InputEx3 = false;
    Link->PressEx3 = false;
    Link->InputEx4 = false;
    Link->PressEx4 = false;
    
    Link->InputStart = false;
    Link->PressStart = false;
    Link->InputMap = false;
    Link->PressMap = false;
}
